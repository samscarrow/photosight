#!/usr/bin/env python3
"""
GUID-Based Photo Identification System for PhotoSight
Links RAW files, processed JPEGs, EXIF data, and YOLO analysis under unique GUIDs
"""

import sys
import json
import logging
import uuid
import time
import requests
from pathlib import Path
from datetime import datetime
import exifread
from typing import Dict, List, Optional, Tuple

# Setup logging
logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')
logger = logging.getLogger(__name__)

# Oracle REST API configuration
ORACLE_CONFIG = {
    'base_url': 'https://GFCA71B2AACCE62-PHOTOSIGHTDB.adb.us-chicago-1.oraclecloudapps.com/ords',
    'username': 'ADMIN',
    'password': 'hdv!gwm6DPQ.ycu.jua',
    'timeout': 30
}

class PhotoGUIDSystem:
    """GUID-based photo identification and management system"""
    
    def __init__(self):
        self.base_url = ORACLE_CONFIG['base_url']
        self.auth = (ORACLE_CONFIG['username'], ORACLE_CONFIG['password'])
        self.timeout = ORACLE_CONFIG['timeout']
        
        # Directory paths
        self.raw_dir = Path("/home/nfs-storage/photosight/ootbraw")
        self.jpeg_dir = Path("/home/nfs-storage/photosight/processed_jpegs")
    
    def execute_sql(self, sql_statement: str) -> dict:
        """Execute SQL statement via Oracle REST API"""
        try:
            response = requests.post(
                f"{self.base_url}/admin/_/sql",
                auth=self.auth,
                json={'sql': sql_statement},
                timeout=self.timeout
            )
            
            if response.status_code == 200:
                return {'success': True, 'data': response.json()}
            else:
                logger.error(f"SQL execution failed: {response.status_code}")
                return {'success': False, 'error': response.text}
                
        except Exception as e:
            logger.error(f"Error executing SQL: {e}")
            return {'success': False, 'error': str(e)}
    
    def create_guid_schema(self) -> bool:
        """Create enhanced Oracle schema for GUID-based photo management"""
        logger.info("üèóÔ∏è Creating GUID-based photo management schema")
        
        # Core photos table with GUID as primary identifier
        photos_table = """
        CREATE TABLE PHOTOS_GUID (
            photo_guid VARCHAR2(36) PRIMARY KEY,
            base_filename VARCHAR2(100) NOT NULL,
            
            -- File locations
            raw_file_path VARCHAR2(500),
            jpeg_file_path VARCHAR2(500),
            
            -- EXIF metadata (from RAW)
            camera_make VARCHAR2(50),
            camera_model VARCHAR2(50),
            lens_model VARCHAR2(100),
            iso NUMBER,
            aperture NUMBER(5,2),
            shutter_speed VARCHAR2(20),
            focal_length NUMBER(5,1),
            date_taken TIMESTAMP,
            flash_fired NUMBER(1),
            white_balance VARCHAR2(20),
            exposure_mode VARCHAR2(20),
            metering_mode VARCHAR2(20),
            exif_data CLOB CHECK (exif_data IS JSON),
            
            -- Processing status
            processing_status VARCHAR2(20) DEFAULT 'discovered',
            has_raw_file NUMBER(1) DEFAULT 0,
            has_jpeg_file NUMBER(1) DEFAULT 0,
            exif_extracted NUMBER(1) DEFAULT 0,
            yolo_analyzed NUMBER(1) DEFAULT 0,
            
            -- YOLO analysis results
            yolo_detections_count NUMBER DEFAULT 0,
            has_people NUMBER(1) DEFAULT 0,
            object_score NUMBER(5,2) DEFAULT 0.0,
            blur_classification VARCHAR2(30),
            meets_quality_threshold NUMBER(1) DEFAULT 0,
            artistic_intent_score NUMBER(5,2) DEFAULT 0.0,
            
            -- Timestamps
            created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
            updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
        )
        """
        
        # YOLO detections linked by GUID
        yolo_detections_table = """
        CREATE TABLE YOLO_DETECTIONS_GUID (
            detection_id NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
            photo_guid VARCHAR2(36) NOT NULL,
            class_name VARCHAR2(50) NOT NULL,
            confidence NUMBER(5,4) NOT NULL,
            bbox_x NUMBER(8,6) NOT NULL,
            bbox_y NUMBER(8,6) NOT NULL,
            bbox_width NUMBER(8,6) NOT NULL,
            bbox_height NUMBER(8,6) NOT NULL,
            subject_priority NUMBER(3,2) DEFAULT 0.0,
            depth_layer VARCHAR2(20) DEFAULT 'unknown',
            detected_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
            
            CONSTRAINT fk_yolo_photo_guid 
                FOREIGN KEY (photo_guid) REFERENCES PHOTOS_GUID(photo_guid)
        )
        """
        
        # Execute table creation
        tables = [
            ("PHOTOS_GUID", photos_table),
            ("YOLO_DETECTIONS_GUID", yolo_detections_table)
        ]
        
        success_count = 0
        for table_name, table_sql in tables:
            logger.info(f"Creating table: {table_name}")
            result = self.execute_sql(table_sql)
            if result['success']:
                logger.info(f"‚úÖ {table_name} created successfully")
                success_count += 1
            else:
                logger.error(f"‚ùå Failed to create {table_name}")
        
        # Create indexes for performance
        indexes = [
            "CREATE INDEX idx_photos_guid_base_filename ON PHOTOS_GUID(base_filename)",
            "CREATE INDEX idx_photos_guid_camera ON PHOTOS_GUID(camera_make, camera_model)",
            "CREATE INDEX idx_photos_guid_lens ON PHOTOS_GUID(lens_model)",
            "CREATE INDEX idx_photos_guid_date ON PHOTOS_GUID(date_taken)",
            "CREATE INDEX idx_yolo_guid_photo ON YOLO_DETECTIONS_GUID(photo_guid)",
            "CREATE INDEX idx_yolo_guid_class ON YOLO_DETECTIONS_GUID(class_name)"
        ]
        
        logger.info("Creating performance indexes...")
        for index_sql in indexes:
            self.execute_sql(index_sql)
        
        logger.info(f"üìä Schema creation complete: {success_count}/{len(tables)} tables created")
        return success_count == len(tables)
    
    def discover_photo_pairs(self) -> List[Dict]:
        """Discover RAW-JPEG pairs and create photo records"""
        logger.info("üîç Discovering RAW-JPEG photo pairs")
        
        # Get all RAW files
        raw_files = {}
        if self.raw_dir.exists():
            for raw_file in self.raw_dir.glob("*.ARW"):
                base_name = raw_file.stem  # DSC04547
                raw_files[base_name] = raw_file
        
        # Get all JPEG files  
        jpeg_files = {}
        if self.jpeg_dir.exists():
            for jpeg_file in self.jpeg_dir.glob("*.jpg"):
                base_name = jpeg_file.stem  # DSC04547
                jpeg_files[base_name] = jpeg_file
        
        # Create photo records for each unique base filename
        all_base_names = set(raw_files.keys()) | set(jpeg_files.keys())
        photo_records = []
        
        for base_name in sorted(all_base_names):
            photo_guid = str(uuid.uuid4())
            
            record = {
                'photo_guid': photo_guid,
                'base_filename': base_name,
                'raw_file_path': str(raw_files[base_name]) if base_name in raw_files else None,
                'jpeg_file_path': str(jpeg_files[base_name]) if base_name in jpeg_files else None,
                'has_raw_file': 1 if base_name in raw_files else 0,
                'has_jpeg_file': 1 if base_name in jpeg_files else 0
            }
            
            photo_records.append(record)
        
        logger.info(f"üìä Discovery complete:")
        logger.info(f"  ‚Ä¢ RAW files found: {len(raw_files)}")
        logger.info(f"  ‚Ä¢ JPEG files found: {len(jpeg_files)}")
        logger.info(f"  ‚Ä¢ Unique photos identified: {len(photo_records)}")
        logger.info(f"  ‚Ä¢ RAW+JPEG pairs: {sum(1 for r in photo_records if r['has_raw_file'] and r['has_jpeg_file'])}")
        logger.info(f"  ‚Ä¢ RAW only: {sum(1 for r in photo_records if r['has_raw_file'] and not r['has_jpeg_file'])}")
        logger.info(f"  ‚Ä¢ JPEG only: {sum(1 for r in photo_records if not r['has_raw_file'] and r['has_jpeg_file'])}")
        
        return photo_records
    
    def extract_exif_from_raw(self, raw_file_path: str) -> Dict:
        """Extract EXIF data from RAW file"""
        exif_data = {
            'camera_make': None,
            'camera_model': None,
            'lens_model': None,
            'iso': None,
            'aperture': None,
            'shutter_speed': None,
            'focal_length': None,
            'date_taken': None,
            'flash_fired': None,
            'white_balance': None,
            'exposure_mode': None,
            'metering_mode': None,
            'raw_exif': {}
        }
        
        try:
            with open(raw_file_path, 'rb') as f:
                tags = exifread.process_file(f, details=False)
                
                # Extract key fields
                make = tags.get('Image Make')
                model = tags.get('Image Model')
                lens = tags.get('EXIF LensModel')
                iso = tags.get('EXIF ISOSpeedRatings')
                aperture = tags.get('EXIF FNumber')
                focal = tags.get('EXIF FocalLength')
                shutter = tags.get('EXIF ExposureTime')
                date_original = tags.get('EXIF DateTimeOriginal')
                flash = tags.get('EXIF Flash')
                wb = tags.get('EXIF WhiteBalance')
                exposure_mode = tags.get('EXIF ExposureMode')
                metering = tags.get('EXIF MeteringMode')
                
                # Convert to clean values
                if make: exif_data['camera_make'] = str(make).strip()
                if model: exif_data['camera_model'] = str(model).strip()
                if lens: exif_data['lens_model'] = str(lens).strip()
                if iso: exif_data['iso'] = str(iso).strip()
                if aperture: exif_data['aperture'] = str(aperture).strip()
                if focal: exif_data['focal_length'] = str(focal).strip()
                if shutter: exif_data['shutter_speed'] = str(shutter).strip()
                if date_original: exif_data['date_taken'] = str(date_original).strip()
                if flash: exif_data['flash_fired'] = str(flash).strip()
                if wb: exif_data['white_balance'] = str(wb).strip()
                if exposure_mode: exif_data['exposure_mode'] = str(exposure_mode).strip()
                if metering: exif_data['metering_mode'] = str(metering).strip()
                
                # Store limited raw EXIF for JSON
                for tag, value in list(tags.items())[:20]:
                    exif_data['raw_exif'][str(tag)] = str(value)[:100]
                    
        except Exception as e:
            logger.error(f"EXIF extraction failed for {Path(raw_file_path).name}: {e}")
        
        return exif_data
    
    def insert_photo_record(self, photo_record: Dict, exif_data: Optional[Dict] = None) -> bool:
        """Insert photo record into Oracle database"""
        try:
            # Prepare base values
            guid = photo_record['photo_guid']
            base_filename = photo_record['base_filename']
            raw_path = photo_record.get('raw_file_path')
            jpeg_path = photo_record.get('jpeg_file_path')
            has_raw = photo_record['has_raw_file']
            has_jpeg = photo_record['has_jpeg_file']
            
            # Prepare EXIF values
            if exif_data:
                make = f"'{exif_data['camera_make']}'" if exif_data['camera_make'] else 'NULL'
                model = f"'{exif_data['camera_model']}'" if exif_data['camera_model'] else 'NULL'
                lens = f"'{exif_data['lens_model']}'" if exif_data['lens_model'] else 'NULL'
                iso = exif_data['iso'] if exif_data['iso'] and exif_data['iso'].isdigit() else 'NULL'
                aperture = exif_data['aperture'] if exif_data['aperture'] else 'NULL'
                shutter = f"'{exif_data['shutter_speed']}'" if exif_data['shutter_speed'] else 'NULL'
                focal = exif_data['focal_length'] if exif_data['focal_length'] else 'NULL'
                date_taken = f"TIMESTAMP '{exif_data['date_taken']}'" if exif_data['date_taken'] else 'NULL'
                exif_json = f"'{json.dumps(exif_data['raw_exif']).replace("'", "''")}'"
                exif_extracted = 1
            else:
                make = model = lens = shutter = exif_json = 'NULL'
                iso = aperture = focal = 'NULL'
                date_taken = 'NULL'
                exif_extracted = 0
            
            # Build INSERT statement
            raw_path_sql = f"'{raw_path}'" if raw_path else 'NULL'
            jpeg_path_sql = f"'{jpeg_path}'" if jpeg_path else 'NULL'
            
            insert_sql = f"""
            INSERT INTO PHOTOS_GUID (
                photo_guid, base_filename, raw_file_path, jpeg_file_path,
                has_raw_file, has_jpeg_file, exif_extracted,
                camera_make, camera_model, lens_model, iso, aperture, 
                shutter_speed, focal_length, date_taken, exif_data,
                processing_status
            ) VALUES (
                '{guid}', '{base_filename}', {raw_path_sql}, {jpeg_path_sql},
                {has_raw}, {has_jpeg}, {exif_extracted},
                {make}, {model}, {lens}, {iso}, {aperture},
                {shutter}, {focal}, {date_taken}, {exif_json},
                'guid_assigned'
            )
            """
            
            result = self.execute_sql(insert_sql)
            
            if result['success']:
                logger.info(f"‚úÖ Inserted photo record: {base_filename} -> {guid[:8]}...")
                return True
            else:
                logger.error(f"‚ùå Failed to insert {base_filename}")
                return False
                
        except Exception as e:
            logger.error(f"Error inserting photo record: {e}")
            return False
    
    def process_photo_discovery(self, max_photos: Optional[int] = None) -> Dict:
        """Complete photo discovery and GUID assignment process"""
        logger.info("üöÄ Starting GUID-based photo discovery and processing")
        
        # Discover photo pairs
        photo_records = self.discover_photo_pairs()
        
        if max_photos:
            photo_records = photo_records[:max_photos]
            logger.info(f"Limited processing to {max_photos} photos")
        
        # Process each photo record
        results = {
            'total_photos': len(photo_records),
            'successful_inserts': 0,
            'exif_extracted': 0,
            'errors': []
        }
        
        for i, photo_record in enumerate(photo_records, 1):
            base_filename = photo_record['base_filename']
            logger.info(f"Processing {i}/{len(photo_records)}: {base_filename}")
            
            # Extract EXIF data if RAW file exists
            exif_data = None
            if photo_record['raw_file_path']:
                exif_data = self.extract_exif_from_raw(photo_record['raw_file_path'])
                results['exif_extracted'] += 1
            
            # Insert photo record
            if self.insert_photo_record(photo_record, exif_data):
                results['successful_inserts'] += 1
            else:
                results['errors'].append(f"Failed to insert {base_filename}")
            
            # Brief pause to avoid overwhelming Oracle
            time.sleep(0.3)
        
        # Final summary
        logger.info("üìä GUID Photo System Deployment Complete!")
        logger.info(f"  Total photos processed: {results['total_photos']}")
        logger.info(f"  Successful database inserts: {results['successful_inserts']}")
        logger.info(f"  EXIF data extracted: {results['exif_extracted']}")
        logger.info(f"  Errors: {len(results['errors'])}")
        
        if results['errors']:
            logger.info("‚ùå Errors encountered:")
            for error in results['errors']:
                logger.info(f"  - {error}")
        
        return results

def main():
    """Main entry point"""
    logger.info("üéØ PhotoSight GUID-Based Photo Identification System")
    logger.info("Linking RAW files, JPEGs, EXIF data, and YOLO analysis")
    
    system = PhotoGUIDSystem()
    
    # Create enhanced schema
    logger.info("üìã Step 1: Creating GUID-based database schema")
    if system.create_guid_schema():
        logger.info("‚úÖ Database schema created successfully")
    else:
        logger.error("‚ùå Failed to create database schema")
        return 1
    
    # Process photo discovery
    logger.info("üìã Step 2: Discovering and processing photos")
    results = system.process_photo_discovery(max_photos=5)  # Process 5 samples first
    
    if results['successful_inserts'] > 0:
        logger.info("‚úÖ GUID Photo System Successfully Deployed!")
        logger.info("üéØ System Benefits:")
        logger.info("   ‚Ä¢ Unique GUID for each photo linking all related data")
        logger.info("   ‚Ä¢ RAW files linked to processed JPEGs")
        logger.info("   ‚Ä¢ Complete EXIF metadata preserved from originals")
        logger.info("   ‚Ä¢ Ready for YOLO analysis integration")
        logger.info("   ‚Ä¢ Non-destructive data management")
        return 0
    else:
        logger.error("‚ùå No photos were successfully processed")
        return 1

if __name__ == "__main__":
    sys.exit(main())